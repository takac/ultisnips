###########################################################################
#                            TEXTMATE SNIPPETS                            #
###########################################################################

# Many of the snippets here use a global option called
# "g:ultisnips_java_brace_style" which, if set to "nl" will put a newline
# before '{' braces.

global !p
def nl(snip):
    if snip.opt("g:ultisnips_java_brace_style", "") == "nl":
        snip += ""
    else:
        snip.rv += " "

endglobal

snippet cn "public constructor" !b
public `!p snip.rv = snip.basename or "unknown"`($1) {
	$0
}
endsnippet

snippet cc "[c]onstuctor [c]all set"  
this.${1:var} = $1;
endsnippet

snippet map "new set" !b
Map<${1:String}, ${2:String}> ${2:map} = new ${3:Hash}Map<$1, $2>();
$0
endsnippet

snippet set "new set" !b
Set<${1:String}> ${2:set} = new ${3:Hash}Set<$1>();
$0
endsnippet

snippet list "new list" !b
List<${1:String}> ${2:list} = new ArrayList<$1>();
$0
endsnippet


snippet col "generic collection" !b
${1:List}<${2:String}> ${3:collection} = new ${4:Hash}$1<$2>();
$0
endsnippet


snippet n "new primitive"
${1:int} ${2:i} = ${3:1};
endsnippet
snippet o "new Object" 
${1:Object} ${2:o} = new $1(${3});
endsnippet

snippet logi "Imports for logging" !b
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
endsnippet

snippet log "Logger" !b
${1:private} static final Logger logger = LoggerFactory.getLogger(${2:`!p
snip.rv = snip.basename or ""`}.class);
endsnippet

snippet sleep "Sleep" !b
try {
	Thread.sleep(${1:1000});
} catch (InterruptedException e){
	e.printStackTrace();
}
endsnippet

snippet ab "abstract" b
abstract 
endsnippet

snippet as "assert" b
assert ${1:test}${2/(.+)/(?1: \: ")/}${2:Failure message}${2/(.+)/(?1:")/};$0
endsnippet

snippet at "assert true" !b
assertTrue(${1:actual});
endsnippet

snippet af "assert equals" !b
assertFalse(${1:actual});$0
endsnippet

snippet ae "assert equals" !b
assertEquals(${1:expected}, ${2:actual});
endsnippet

snippet br "break"
break;

endsnippet

snippet cs "case" b
case $1:
	$2
$0
endsnippet

snippet ca "catch" b
catch (${1:Exception} ${2:e})`!p nl(snip)`{
	$0
}
endsnippet

snippet cl "class" b
class ${1:`!p
snip.rv = snip.basename or "untitled"`} ${2:extends ${3:Parent} }${4:implements ${5:Interface} }{
	$0
}
endsnippet

snippet cos "constant string" b
public static final String ${1:var} = "$2";$0
endsnippet

snippet co "constant" b
public static final ${1:String} ${2:var} = $3;$0
endsnippet

snippet de "default" b
default:
	$0
endsnippet

snippet elif "else if" b
else if ($1)`!p nl(snip)`{
	$0
}
endsnippet

snippet /el(se)?/ "else" br
else`!p nl(snip)`{
	$0
}
endsnippet

snippet f "final"
final 
endsnippet

snippet fore "for (each)" b
for ($1 $2 : $3)`!p nl(snip)`{
	$0
}
endsnippet

snippet fori "for" b
for (int ${1:i} = 0; $1 < $2; $1++)`!p nl(snip)`{
	$0
}
endsnippet
snippet for "for" b
for ($1; $2; $3)`!p nl(snip)`{
	$0
}
endsnippet

snippet if "if" b
if ($1)`!p nl(snip)`{
	$0
}
endsnippet

snippet imt "import junit_framework_TestCase;"  b
import junit.framework.TestCase;
$0
endsnippet

snippet im "import"  b
import 
endsnippet

snippet in "interface" b
interface ${1:`!p snip.rv = snip.basename or "untitled"`} ${2:extends ${3:Parent} }{
	$0
}
endsnippet

snippet j.b "java_beans_" i
java.beans.
endsnippet

snippet j.i "java_io" i
java.io.
endsnippet

snippet j.m "java_math" i
java.math.
endsnippet

snippet j.n "java_net_" i
java.net.
endsnippet

snippet j.u "java_util_"  i
java.util.
endsnippet

snippet /^\s*[Ss](tr?)?/ "String" r
String 
endsnippet

snippet try "try/catch" !b
try {
	$1
} catch(${2:Exception} ${3:e}){
	${4:e.printStackTrace();}
}
endsnippet

snippet main "method (main)" b
public static void main(String[] args)`!p nl(snip)`{
	$0
}
endsnippet

snippet m "method" b
${1:private} ${2:void} ${3:method}($4) ${5:throws $6 }{
	$0
}

endsnippet

snippet pa "package" b
package 
endsnippet

snippet pne "print" b
System.err.print($1);$0
endsnippet

snippet pe "println"  b
System.err.println($1);$0
endsnippet

snippet pn "print no nl" b
System.out.print($1);$0
endsnippet

snippet p "println"  b
System.out.println($1);$0
endsnippet

snippet pr "private" b
private 
endsnippet

snippet po "protected" b
protected 
endsnippet

snippet pu "public" b
public 
endsnippet

snippet re "return" b
return 
endsnippet

snippet "sta?" "static" r
static 
endsnippet

snippet sw "switch" b
switch ($1)`!p nl(snip)`{
	case $2: $0
}
endsnippet

snippet sy "synchronized"
synchronized 
endsnippet

snippet tc "test case"
public class ${1:`!p snip.rv = snip.basename or "untitled"`} extends ${2:TestCase}`!p nl(snip)`{
	$0
}
endsnippet

snippet t "test" b
@Test
public void ${1:name}Test() {
	$0
}
endsnippet

snippet tt "test" b
@Test
public void ${1:name}Test() ${2:throws ${3:Exception}}`!p nl(snip)`{
	$0
}
endsnippet

snippet exp "Easy mock help" !b
EasyMock.expect(${1:mock}.${2:method}()).andReturn(${3:value});
endsnippet

snippet th "throw" b
throw $0
endsnippet

snippet v "variable" b
${1:String} ${2:var}${3: = ${0:null}};
endsnippet

snippet wh "while" b
while ($1)`!p nl(snip)`{
	$0
}
endsnippet

# vim:ft=snippets:
